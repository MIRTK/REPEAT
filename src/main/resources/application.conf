# ----------------------------------------------------------------------------------------------------------------------
# Auxiliary software tools
software {
  care       = care         # Local path of "care" executable used to pack binary files (http://reproducible.io/#downloads)
  care-tmp   = /tmp         # Temporary directory for creating archive files
  tar        = /bin/tar     # Local path of "tar" executable used to create archive files
  repository = Bin          # Local directory containing pre-packed CARE archives
  shared     = true         # Whether software installations are shared between all compute nodes
                            # true:  Absolute paths of binaries are used to access the same binary
                            #        files on a shared network drive. If command names are given only
                            #        the software is expected to be available in the PATH on each node.
                            # false: Binary files used by a remote task are packed using CARE. The resulting
                            #        (self-extracting) archive is copied to the remote and extracted into
                            #        the working directory of the task.
}

irtk {
  dir = Bin/IRTK  # Directory where the binary IRTK executables are located
  # File name suffixes/extensions
  suffix {
    img = .nii.gz # Intensity images
    msk = .nii.gz # Foreground mask images
    seg = .nii.gz # Segmentation images
    dof = .dof.gz # IRTK transformation files
    jac = .nii.gz # Jacobian determinant map
    pts = .vtp    # VTK poly data files
  }
  # Default commands used for evaluating registration results (cf. section "Registration tools" below)
  apply     = transformation "${source}" "${out}" -target "${target}" -dofin "${phi}" -matchInputType
  apply-nn  = ${irtk.apply} -nn
  apply-vtk = ptransformation "${target}" "${out}" -dofin "${phi}"
  invert    = ffdinvert "${phi}" "${inv}"
  jacobian  = jacobian "${target}" "${out}" "${phi}" -mask "${mask}" -outside nan -float
}

# ----------------------------------------------------------------------------------------------------------------------
# Task execution environment
environment {
  # Name of default execution environment (i.e., "local", "slurm[-<queue>]", "condor[-<queue>]", or "egi") for...
  short = local # ...short running jobs (<1hr)
  long  = local # ...long running jobs (>=1hr)
  # Default environment properties
  memory = 4096
  nodes = 1
  threads = 1
  # Local environment
  local {
    memory = ${environment.memory}
    nodes = ${environment.nodes}
    threads = ${environment.threads}
    requirements = []
  }
  # SLURM configuration
  slurm {
    user = ${USER}
    host = predict5.doc.ic.ac.uk
    port = 22
    auth = id_dsa
    queue {
      short = short # Name of queue for short running jobs (<1hr)
      long  = long  # Name of queue for long running jobs (>=1hr)
    }
    memory = ${environment.memory}
    nodes = ${environment.nodes}
    threads = ${environment.threads}
    requirements = []
  }
  # HTCondor configuration
  condor {
    user = ${USER}
    host = merapi.doc.ic.ac.uk
    port = 22
    auth = id_dsa
    memory = ${environment.memory}
    nodes = ${environment.nodes}
    threads = ${environment.threads}
    requirements = []
  }
  # TODO: European Grid Infrastructure (EGI) configuration
  egi {

  }
}

# ----------------------------------------------------------------------------------------------------------------------
# Datasets used for evaluation
dataset {
  shared = true    # Whether files are located on storage which is shared with cluster compute nodes (can be overriden by each dataset)
  dir    = Dataset # Default base directory for all datasets (can be overridden by each dataset)
  # Default template image
  template {
    id      = mni305
    dir     = ../Templates
    name    = "${refId}.cor.nii.gz"
    bgvalue = 0
  }
  # MICCAI 2012 Workshop on multi-atlas labeling
  MAL35 {
    # Population specific template image (default template used if unspecified)
    template {
      id      = ${dataset.template.id}
      dir     = ../${dataset.template.dir}
      name    = ${dataset.template.name}
      bgvalue = ${dataset.template.bgvalue}
    }
    # Intensity images to be registered
    images {
      dir     = Images
      csv     = Info/Images.csv
      name    = "${imgId}_3.nii.gz"
      bgvalue = 0
    }
    # Foreground mask images (optional)
    masks {
      dir  = Masks/FreeSurfer
      name = "${imgId}.nii.gz"
    }
    # Corresponding (manual/semi-automatic) expert segmentations
    labels {
      dir  = Labels
      csv  = Info/Labels.csv
      name = "${imgId}_3_glm.nii.gz"
    }
  }
}

# ----------------------------------------------------------------------------------------------------------------------
# Default file name suffixes/extensions
suffix {
  img = ${irtk.suffix.img}
  msk = ${irtk.suffix.msk}
  seg = ${irtk.suffix.seg}
  dof = ${irtk.suffix.dof}
  pts = ${irtk.suffix.pts}
  csv = .csv
  log = .log
}

# ----------------------------------------------------------------------------------------------------------------------
# Directories in which shared binary files and output files are stored
workspace {
  dir       = Workspace # Top-level directory of workspace
  shared    = true      # Whether workspace is located on storage which is shared among cluster compute nodes
  link.csv  = false     # Whether to allow symlinks to CSV files outside workspace, otherwise force copy (recommended)
  link.orig = true      # Whether to allow symlinks to original images of dataset (recommended), otherwise force copy
  link.ref  = true      # Whether to allow symlinks to template image of dataset (recommended), otherwise force copy
  # Input and output intensity image files
  images {
    dir      = "${setId}/images"
    csv      = "${setId}/params/images"${suffix.csv}
    orig     = ${workspace.images.dir}"/original/${imgId}"${suffix.img}
    mask     = ${workspace.images.dir}"/masks/${imgId}"${suffix.msk}
    padded   = ${workspace.images.dir}"/padded/${imgId}"${suffix.img}
    points   = ${workspace.images.dir}"/points/${imgId}"${suffix.pts}
    output   = ${workspace.images.dir}"/${regId}-${parId}/${imgId}"${suffix.img}
    average  = ${workspace.images.dir}"/average/${regId}-${parId/${refId}"${suffix.img}
    template = ${workspace.images.dir}"/template/${refId}"${suffix.img}
  }
  # Input and output segmentation image file
  labels {
    dir    = "${setId}/labels"
    csv    = "${setId}/params/labels"${suffix.csv}
    orig   = ${workspace.labels.dir}"/original/${imgId}"${suffix.seg}
    output = ${workspace.labels.dir}"/${regId}-${parId}/${imgId}"${suffix.seg}
  }
  # Registration parameters
  params = "${setId}/params/${regId}"${suffix.csv}
  # Transformations computed by spatial normalization and pre-alignment workflows
  dofs {
    dir    = "${setId}/dofs"
    affine = ${workspace.dofs.dir}"/${regId}-aff/${tgtId},${srcId}"${suffix.dof}
    output = ${workspace.dofs.dir}"/${regId}-${parId}/${phiPre}${tgtId},${srcId}${phiSuf}"
  }
  # Voxel-wise registration evaluation maps
  maps {
    dir = "${setId}/maps"
  }
  # Results of each registration
  tables {
    dir    = "${setId}/tables"
    append = true
  }
  # Settings for command output logging
  logs {
    dir    = "${setId}/logs"
    append = false
    flush  = false
    tee    = false
  }
}

# ----------------------------------------------------------------------------------------------------------------------
# Registration tools to be evaluated
#
# registration {
#   <name> {
#     command     = Registration command
#     params      = CSV file with additional parameters for which different values are to be explored
#     config      = Template of registration configuration file (optional)
#     symmetric   = Whether registration is truely symmetric in which case only half the registrations are executed
#     environment = Name of "environment" on which to execute registration command (default: ${environment.long})
#     memory      = Maximum amount of memory in MB required by registration command (default: ${environment}.memory)
#     threads     = Maximum number of threads/cores utilized by registration command (default: ${environment}.threads)
#     aff-suffix  = File name suffix for transformation written by dof2aff tool (default: irtk.dof-suffix)
#     phi-suffix  = File name suffix for transformation written by command tool (default: irtk.dof-suffix)
#     jac-suffix  = File name suffix for Jacobian determinant map written by jacobian tool (default: irtk.jac-suffix)
#     dof2aff     = Convert affine IRTK transformation to input transformation  (default: none)
#     phi2dof     = Convert output transformation to IRTK transformation (default: none)
#     apply       = Deform intensity image (using linear interpolation) (default: irtk.apply)
#     apply-nn    = Deform label image using nearest neighbor interpolation (default: irtk.apply-nn)
#     apply-vtk   = Transform vtkPolyData points by one or multiple composed transformations (default: irtk.apply-vtk)
#     jacobian    = Compute determinant of transformation Jacobian (default: irtk.jacobian)
#   }
# }
#
# Each of the above entries are the commands used for the individual steps, with variables ${name}
# (NOTE: must be enclosed in double quotes to not expand these to other configuration file entries)
# for input and output file paths and parameters listed in the "params" CSV file.
# The available variables for each command are:
#
# dof2aff:  dof      Input transformation in IRTK format
#           aff      Output transformation in format suitable for registration "command"
#
# command:  target   Fixed target image
#           source   Moving source image
#           aff      Affine input transformation
#           phi      Output transformation
#           [par]    Any parameter named by the header in the "params" CSV file
#           config   Name of configuration file with substituted parameters
#
# phi2dof:  phi      Input transformation as written by registration "command"
#           dof      Output transformation in IRTK format
#
# If no phi2dof tool is specified, the following commands are required. These are optional otherwise,
# in which case the respective IRTK tools are used instead.
#
# apply:    target   Fixed target image defining image grid on which to resample the source image
#           source   Input source image
#           phi      Transformation as written by registration "command"
#           out      Resampled/deformed source image
#
# apply-nn: Same as "apply" but input images contain discrete segmentation labels
#
# jacobian: target   Fixed target image specifying the attributes of the output image
#           phi      Transformation as written by registration "command"
#           out      Output Jacobian determinant map (i.e., image)
#
registration {
  # Default location of CSV files with registration parameters to explore
  params {
    dir  = "Params/${setId}"
    name = "${regId}"${suffix.csv}
  }
  # IRTK (original implementation using finite differences to approximate gradient of energy function)
  nreg {
    bin     = ${irtk.dir}/nreg
    command = ${registration.nreg.bin} "${target}" "${source}" -threads ${registration.nreg.threads} -parin "${config}" -dofin "${aff}" -dofout "${phi}"
    threads = ${environment.threads}
    config  = """
                |#
                |# Non-rigid registration parameters
                |#
                |
                |Lambda1                           = ${Lambda1}
                |Lambda2                           = ${Lambda2}
                |Lambda3                           = ${Lambda3}
                |Control point spacing in X        = ${InitialControlPointSpacing}
                |Control point spacing in Y        = ${InitialControlPointSpacing}
                |Control point spacing in Z        = ${InitialControlPointSpacing}
                |Subdivision                       = True
                |Speedup factor                    = 1
                |MFFDMode                          = True
                |
                |#
                |# Registration parameters
                |#
                |
                |No. of resolution levels          = ${NoOfResolutionLevels}
                |No. of bins                       = ${NoOfBins}
                |Epsilon                           = ${Epsilon}
                |Padding value                     = ${bgvalue}
                |Similarity measure                = ${SimilarityMeasure}
                |Interpolation mode                = ${InterpolationMode}
                |Optimization method               = ${OptimizationMethod}
                |
                |#
                |# Registration parameters for resolution level 1
                |#
                |
                |Resolution level                  = 1
                |Target blurring (in mm)           = 0.5
                |Target resolution (in mm)         = 1 1 1
                |Source blurring (in mm)           = 0.5
                |Source resolution (in mm)         = 1 1 1
                |No. of iterations                 = ${NoOfIterations}
                |No. of steps                      = ${NoOfSteps}
                |Length of steps                   = 3.2
                |Delta                             = 0
                |
                |#
                |# Registration parameters for resolution level 2
                |#
                |
                |Resolution level                  = 2
                |Target blurring (in mm)           = 1
                |Target resolution (in mm)         = 2 2 2
                |Source blurring (in mm)           = 1
                |Source resolution (in mm)         = 2 2 2
                |No. of iterations                 = ${NoOfIterations}
                |No. of steps                      = ${NoOfSteps}
                |Length of steps                   = 6.4
                |Delta                             = 0
                |
                |#
                |# Registration parameters for resolution level 3
                |#
                |
                |Resolution level                  = 3
                |Target blurring (in mm)           = 2
                |Target resolution (in mm)         = 4 4 4
                |Source blurring (in mm)           = 2
                |Source resolution (in mm)         = 4 4 4
                |No. of iterations                 = ${NoOfIterations}
                |No. of steps                      = ${NoOfSteps}
                |Length of steps                   = 12.8
                |Delta                             = 0
                |
                |#
                |# Registration parameters for resolution level 4
                |#
                |
                |Resolution level                  = 4
                |Target blurring (in mm)           = 4
                |Target resolution (in mm)         = 8 8 8
                |Source blurring (in mm)           = 4
                |Source resolution (in mm)         = 8 8 8
                |No. of iterations                 = ${NoOfIterations}
                |No. of steps                      = ${NoOfSteps}
                |Length of steps                   = 25.6
                |Delta                             = 0
              """
  }
  # IRTK 2 (re-implementation with analytic calculation of energy function gradient, significantly faster)
  nreg2 {
    bin     = ${irtk.dir}/nreg2
    command = ${registration.nreg2.bin} "${target}" "${source}" -threads ${registration.nreg2.threads} -parin "${config}" -dofin "${aff}" -dofout "${phi}"
    threads = ${environment.threads}
    config  = """
                |#
                |# Non-rigid registration parameters
                |#
                |
                |Lambda1                           = ${Lambda1}
                |Lambda2                           = ${Lambda2}
                |Lambda3                           = ${Lambda3}
                |Control point spacing in X        = ${InitialControlPointSpacing}
                |Control point spacing in Y        = ${InitialControlPointSpacing}
                |Control point spacing in Z        = ${InitialControlPointSpacing}
                |Subdivision                       = True
                |MFFDMode                          = True
                |
                |#
                |# Registration parameters
                |#
                |
                |No. of resolution levels          = ${NoOfResolutionLevels}
                |No. of bins                       = ${NoOfBins}
                |Epsilon                           = ${Epsilon}
                |Padding value                     = ${bgvalue}
                |Source padding value              = -32768
                |Similarity measure                = ${SimilarityMeasure}
                |Interpolation mode                = ${InterpolationMode}
                |
                |#
                |# Registration parameters for resolution level 1
                |#
                |
                |Resolution level                  = 1
                |Target blurring (in mm)           = 0.5
                |Target resolution (in mm)         = 1 1 1
                |Source blurring (in mm)           = 0.5
                |Source resolution (in mm)         = 1 1 1
                |No. of iterations                 = ${NoOfIterations}
                |Minimum length of steps           = 0.01
                |Maximum length of steps           = 1
                |
                |#
                |# Registration parameters for resolution level 2
                |#
                |
                |Resolution level                  = 2
                |Target blurring (in mm)           = 1
                |Target resolution (in mm)         = 2 2 2
                |Source blurring (in mm)           = 1
                |Source resolution (in mm)         = 2 2 2
                |No. of iterations                 = ${NoOfIterations}
                |Minimum length of steps           = 0.02
                |Maximum length of steps           = 2
                |
                |#
                |# Registration parameters for resolution level 3
                |#
                |
                |Resolution level                  = 3
                |Target blurring (in mm)           = 2
                |Target resolution (in mm)         = 4 4 4
                |Source blurring (in mm)           = 2
                |Source resolution (in mm)         = 4 4 4
                |No. of iterations                 = ${NoOfIterations}
                |Minimum length of steps           = 0.04
                |Maximum length of steps           = 4
                |
                |#
                |# Registration parameters for resolution level 4
                |#
                |
                |Resolution level                  = 4
                |Target blurring (in mm)           = 4
                |Target resolution (in mm)         = 8 8 8
                |Source blurring (in mm)           = 4
                |Source resolution (in mm)         = 8 8 8
                |No. of iterations                 = ${NoOfIterations}
                |Minimum length of steps           = 0.08
                |Maximum length of steps           = 8
              """
  }
  # IRTK 3 (modular and more generic re-implementation of IRTK 2 registration package, even faster)
  ireg { // common settings of ireg-* registration entries, cannot be used directly
    bin     = ${irtk.dir}/ireg
    command = ${registration.ireg.bin} "${target}" "${source}" -threads ${registration.ireg.threads} -parin "${config}" -dofin "${aff}" -dofout "${phi}"
    threads = ${environment.threads}
    config  = """
                |Strict step length range = No
                |Maximum streak of rejected steps = 1
                |Control point spacing = ${ControlPointSpacing}
                |Bending energy weight = ${BendingEnergyWeight}
                |Background value = ${bgvalue}
              """
  }
  ireg-ffd { # classic B-spline FFD transformation model
    command = ${registration.ireg.command} -model FFD
    threads = ${registration.ireg.threads}
    config  = ${registration.ireg.config}
  }
  ireg-svffd { # diffeomorphic transformation parameterized by stationary velocity field represented as B-spline function
    command = ${registration.ireg.command} -model SVFFD
    threads = ${registration.ireg.threads}
    config  = ${registration.ireg.config}"""
                |Integration method = ${IntegrationMethod}
                |No. of BCH terms = ${NoOfBCHTerms}
              """
  }
  # NiftyReg
  reg_f3d { # classic B-spline transformation model (cf. IRTK)
    dir        = Bin/NiftyReg
    bin        = ${registration.reg_f3d.dir}/reg_f3d
    suffix.aff = .txt
    suffix.phi = -cpp.nii.gz
    dof2aff    = ${irtk.dir}/dof2niftk "${dof}" "${aff}"
    command    = ${registration.reg_f3d.bin} """
                   -ref ${target}
                   -flo ${source}
                   -aff ${aff}
                   -cpp ${phi}
                   -sx ${ds}
                   -be ${be}
                   -ln ${ln}
                   -maxit ${maxit}
                   -pad ${bgvalue}
                 """
    phi2dof    = ${irtk.dir}/niftk2dof "${phi}" "${dof}" -cpp
  }
  reg_f3d-vel { # diffeomorphic transformation parameterized by stationary velocity field represented as B-spline function
    suffix.aff = ${registration.reg_f3d.suffix.aff}
    suffix.phi = -vel.nii.gz
    dof2aff    = ${irtk.dir}/dof2niftk "${dof}" "${aff}"
    command    = ${registration.reg_f3d.command} -vel
    params     = reg_f3d${suffix.csv}
    phi2dof    = ${irtk.dir}/niftk2dof "${phi}" "${dof}" -vel
  }
}

# ----------------------------------------------------------------------------------------------------------------------
# Evaluation of transformation obtained by registration command
evaluation {
  # Runtime of registration command
  runtime {
    measure = [user, system, total, real]
    units   = seconds
    results = "${regId}-${parId}/Runtime"
    summary = "Runtime"
  }
  # Residual dissimilarity (i.e., similarity of registered images)
  similarity {
    measure = [SSD, CC, NMI, MI]
    results = "${regId}-${parId}/Similarity"
    summary = "Similarity"
  }
  # Overlap of propagated labels and fixed target image labels
  overlap {
    measure = [DSC, JSI]                        # Overlap measures to compute and report
    groups  = [Cortical, Non-Cortical, Overall] # Groups of labels for which to compute mean and standard deviation
    results = "${regId}-${parId}/${measure}_${columns}"
    summary = "${measure}_${columns}"
  }
  # Jacobian determinant of transformation
  jacobians {
    log     = false # Whether to evaluate logarithm of Jacobian determinant values
    measure = [Normal distribution, Extrema, 5th%, 95th%, Mean <5th%, Mean >95th%]
    output  = "jacobians/${regId}-${parId}/${tgtId},${srcId}"
    results = "${regId}-${parId}/Jacobian"
  }
  # Inverse-consistency error
  inverse-consistency {
    measure = true  # Whether to evaluate inverse-consistency error
    squared = false # Whether to evaluate squared Euclidean distances
    output  = "inverse-consistency/${regId}-${parId}/${refId}"
  }
  # Transitivity error
  transitivity {
    measure = true  # Whether to evaluate transitivity error
    squared = false # Whether to evaluate squared Euclidean distances
    output  = "transitivity/${regId}-${parId}/${refId}"
  }
  # Sharpness of intensity average image
  intensity-average {
    measure = [Var]
    outputs = "intensity-${measure}/${regId}-${parId}/${refId}"
  }
}
